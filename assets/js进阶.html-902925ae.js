const e=JSON.parse('{"key":"v-7fb39ec2","path":"/code/webDev/javascript/js%E8%BF%9B%E9%98%B6.html","title":"JS 进阶","lang":"zh-CN","frontmatter":{"title":"JS 进阶","icon":"jinjie","date":"2022-10-07T00:00:00.000Z","category":["JS"],"tag":["编程进阶"],"description":"作用域问题 JS的作用域可以分为两种：全局作用域和函数作用域。 全局作用域： 全局作用域中只有一个全局对象即window实例。在全局作用域中创建的变量和函数最后都会挂载到window对象上，并且可以在在页面的任意位置访问。 函数作用域： 函数执行时创建的作用域，在函数执行完毕就会销毁。内部创建的变量不能在外部访问。变量寻找机制是先找当前内部自身的，找不到就层层向上寻找，直到找到全局作用域。 初期JS只能用 var 声明变量，没有块级作用域。ES6新引入的 let 和 const 声明的变量具有块级作用域。所以现在更推荐使用 let 声明变量。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/code/webDev/javascript/js%E8%BF%9B%E9%98%B6.html"}],["meta",{"property":"og:site_name","content":"正の博客"}],["meta",{"property":"og:title","content":"JS 进阶"}],["meta",{"property":"og:description","content":"作用域问题 JS的作用域可以分为两种：全局作用域和函数作用域。 全局作用域： 全局作用域中只有一个全局对象即window实例。在全局作用域中创建的变量和函数最后都会挂载到window对象上，并且可以在在页面的任意位置访问。 函数作用域： 函数执行时创建的作用域，在函数执行完毕就会销毁。内部创建的变量不能在外部访问。变量寻找机制是先找当前内部自身的，找不到就层层向上寻找，直到找到全局作用域。 初期JS只能用 var 声明变量，没有块级作用域。ES6新引入的 let 和 const 声明的变量具有块级作用域。所以现在更推荐使用 let 声明变量。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-21T09:07:23.000Z"}],["meta",{"property":"article:author","content":"正"}],["meta",{"property":"article:tag","content":"编程进阶"}],["meta",{"property":"article:published_time","content":"2022-10-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-21T09:07:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JS 进阶\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-10-07T00:00:00.000Z\\",\\"dateModified\\":\\"2023-07-21T09:07:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"正\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"作用域问题","slug":"作用域问题","link":"#作用域问题","children":[]},{"level":2,"title":"this指向问题","slug":"this指向问题","link":"#this指向问题","children":[]},{"level":2,"title":"闭包","slug":"闭包","link":"#闭包","children":[]},{"level":2,"title":"防抖与节流","slug":"防抖与节流","link":"#防抖与节流","children":[]},{"level":2,"title":"浅拷贝与深拷贝","slug":"浅拷贝与深拷贝","link":"#浅拷贝与深拷贝","children":[]},{"level":2,"title":"new/构造函数创建流程","slug":"new-构造函数创建流程","link":"#new-构造函数创建流程","children":[]},{"level":2,"title":"原型与原型链","slug":"原型与原型链","link":"#原型与原型链","children":[]},{"level":2,"title":"事件循环","slug":"事件循环","link":"#事件循环","children":[]},{"level":2,"title":"正则表达式","slug":"正则表达式","link":"#正则表达式","children":[]}],"git":{"createdTime":1689840466000,"updatedTime":1689930443000,"contributors":[{"name":"zzlm0107","email":"zzlm0107@163.com","commits":2}]},"readingTime":{"minutes":10.38,"words":3114},"filePathRelative":"code/webDev/javascript/js进阶.md","localizedDate":"2022年10月7日","excerpt":"<h2> 作用域问题</h2>\\n<p>JS的作用域可以分为两种：全局作用域和函数作用域。</p>\\n<ul>\\n<li>\\n<p><strong>全局作用域：</strong> 全局作用域中只有一个全局对象即window实例。在全局作用域中创建的变量和函数最后都会挂载到window对象上，并且可以在在页面的任意位置访问。</p>\\n</li>\\n<li>\\n<p><strong>函数作用域：</strong> 函数执行时创建的作用域，在函数执行完毕就会销毁。内部创建的变量不能在外部访问。变量寻找机制是先找当前内部自身的，找不到就层层向上寻找，直到找到全局作用域。</p>\\n</li>\\n</ul>\\n<p>初期JS只能用 <code>var</code> 声明变量，没有块级作用域。ES6新引入的 <code>let</code> 和 <code>const</code> 声明的变量具有块级作用域。所以现在更推荐使用 <code>let</code> 声明变量。</p>","autoDesc":true}');export{e as data};
