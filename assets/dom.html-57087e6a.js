import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as s,f as t}from"./app-772e3d11.js";const a={},o=t(`<p>Document Object Model 文档对象模型，通过DOM可以来任意来修改网页中各个内容</p><p>网页中浏览器已经为我们提供了<strong>document对象</strong>，<strong>它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。</strong></p><h2 id="元素" tabindex="-1"><a class="header-anchor" href="#元素" aria-hidden="true">#</a> 元素</h2><h3 id="查找" tabindex="-1"><a class="header-anchor" href="#查找" aria-hidden="true">#</a> 查找</h3><p>下面是一些查找全局元素的方式：</p><ul><li><p>获取HTML元素： <code>document.documentElement</code></p></li><li><p>获取body元素： <code>document.body</code></p></li><li><p>根据id获取元素： <code>document.getElementById(&quot;id属性值&quot;)</code></p></li><li><p>根据标签名获取元素数组： <code>document.getElementsByTagName(&quot;标签名&quot;)</code></p></li><li><p>根据类名获取元素数组：<code>document.getElementsByClassName(&quot;类名&quot;)</code></p></li><li><p>自定义查找第一个匹配元素： <code>document.querySelector(&quot;名称&quot;)</code> 名称规则与css选择器相同</p></li><li><p>自定义查找全部匹配元素： <code>document.querySelectorAll(&quot;名称&quot;)</code> 名称规则与css选择器相同</p></li></ul><p>下面是查找指定元素前后或内部元素的方式： <strong>设 el 为找到的指定元素</strong></p><ul><li><p><code>el.parentNode</code> 获取当前元素的父元素节点</p></li><li><p><code>el.childNodes</code> 获取当前元素的所有子节点，包括子元素和空白文本节点。（不常用）</p></li><li><p><code>el.children</code> 获取当前元素的所有子元素，仅元素标签。</p></li><li><p><code>el.firstChild/lastChild</code> 获取当前元素的第一个/最后一个子节点。包括空白文本节点。（不常用）</p></li><li><p><code>el.firstElementChild/lastElementChild</code> 获取当前元素的第一个/最后一个子元素。仅元素标签。</p></li><li><p><code>el.previousSibling/nextSibling</code> 获取当前元素的前一个/后一个兄弟节点。包括空白文本节点。（不常用）</p></li><li><p><code>el.previousSibling/nextSibling</code> 获取当前元素的前一个/后一个兄弟元素。仅元素标签。</p></li></ul><h3 id="修改" tabindex="-1"><a class="header-anchor" href="#修改" aria-hidden="true">#</a> 修改</h3><p>查找到页面元素后就可以对其属性值进行读取和修改</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;#root&quot;</span><span class="token punctuation">)</span>

<span class="token comment">// el.className 获取元素类名列表 仅用于读取</span>
<span class="token comment">// el.classList 获取元素类名列表数组 可用于修改和删除</span>
<span class="token comment">// el.style.xxx 获取元素样式</span>
<span class="token comment">// el.innerHTML 获取元素内部内容</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="增加" tabindex="-1"><a class="header-anchor" href="#增加" aria-hidden="true">#</a> 增加</h3><ol><li><code>document.write(内容)</code> 直接将内容重绘到页面上，会将之前的页面内容全部删除</li><li><code>el.innerHTML = 内容</code> 直接将元素内部值修改为html结构</li><li><code>document.createElement(标签名)</code> 创建一个指定的标签，仅创建标签，插入页面还需要其他操作： <ul><li><code>el.appendChild(newNode)</code> 将新创建的元素插入到指定元素的子节点列表末尾</li><li><code>el.insertBefore(newNode, child)</code> 将新创建的元素插入到指定元素的指定子节点之前</li></ul></li></ol><p>此外还有克隆节点：</p><p><code>el.cloneNode(flag)</code> 克隆元素，flag为false时只克隆元素本身，为true时还会克隆内部子节点。</p><h3 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h3><ul><li><code>el.removeChild(child)</code> 移除元素的指定子节点，返回删除的节点</li></ul><h3 id="自定义属性" tabindex="-1"><a class="header-anchor" href="#自定义属性" aria-hidden="true">#</a> 自定义属性</h3><p>对于内置的属性，我们可以直接使用 <code>element.xxx</code> 获取，但对于自定义属性需要使用方法来获取</p><ul><li><code>element.getAttribute(属性名)</code> 获取自定义属性</li><li><code>element.setAttribute(属性名，属性值)</code> 修改自定义属性</li><li><code>element.removeAttribute(属性名)</code> 移除自定义属性</li></ul><h3 id="元素偏移量-offset" tabindex="-1"><a class="header-anchor" href="#元素偏移量-offset" aria-hidden="true">#</a> 元素偏移量 offset</h3><p>我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>element.offsetParent</td><td>返回作为该元素带有定位的父级元素，如果父级都没有定位则返回body</td></tr><tr><td>element.offsetTop</td><td>返回距离作为该元素带有定位的父元素上边框的偏移</td></tr><tr><td>element.offsetLeft</td><td>返回距离作为该元素带有定位的父元素左边框的偏移</td></tr><tr><td>element.offsetWidth</td><td>返回自身padding、边框、内容区的宽度，返回的数值不带单位</td></tr><tr><td>element.offsetHeight</td><td>返回自身padding、边框、内容区的高度，返回的数值不带单位</td></tr></tbody></table><h3 id="元素可视区-client" tabindex="-1"><a class="header-anchor" href="#元素可视区-client" aria-hidden="true">#</a> 元素可视区 client</h3><p>我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>element.clientTop</td><td>返回元素上边框的大小</td></tr><tr><td>element.clientLeft</td><td>返回元素左边框的大小</td></tr><tr><td>element.clientWidth</td><td>返回自身padding、内容区的宽度，不包含边框返回的数值不带单位</td></tr><tr><td>element.clientHeight</td><td>返回自身padding、内容区的宽度，不包含边框返回的数值不带单位</td></tr></tbody></table><h3 id="元素滚动-scroll" tabindex="-1"><a class="header-anchor" href="#元素滚动-scroll" aria-hidden="true">#</a> 元素滚动 scroll</h3><p>我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>element.scrollTop</td><td>返回被卷去的上方距离</td></tr><tr><td>element.scrollLeft</td><td>返回被卷去的左边距离</td></tr><tr><td>element.scrollWidth</td><td>返回自身实际宽度，不包含边框返回的数值不带单位</td></tr><tr><td>element.scrollHeight</td><td>返回自身实际高度，不包含边框返回的数值不带单位</td></tr></tbody></table><p><strong>页面滚动的距离通过 window.pageXOffset 获得</strong></p><h2 id="事件" tabindex="-1"><a class="header-anchor" href="#事件" aria-hidden="true">#</a> 事件</h2><p>事件即为页面元素在某种操作下执行的一定回调方法，此即触发了一个事件。</p><p>事件三要素：触发源，触发方式，触发回调</p><h3 id="事件绑定" tabindex="-1"><a class="header-anchor" href="#事件绑定" aria-hidden="true">#</a> 事件绑定</h3><ol><li><p><strong>on + 事件类型</strong> 例如 onClick，小驼峰书写方式。这种方式只能给元素绑定一个事件。</p></li><li><p><strong>addEventListener</strong> 通过此方法添加事件，可以给元素绑定多个事件。有三个参数，分别是事件类型，事件回调，是否开启捕获模式（默认false）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#root&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;第1种方式&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;第2种方式&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

el<span class="token punctuation">.</span>onClick <span class="token operator">=</span> fn1 <span class="token comment">// 第一种 on + 事件类型 绑定</span>
el<span class="token punctuation">.</span>onClick <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 解除绑定</span>

el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> fn2<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// 第二种 </span>
el<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span> <span class="token comment">// 解除绑定</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="事件对象" tabindex="-1"><a class="header-anchor" href="#事件对象" aria-hidden="true">#</a> 事件对象</h3><p>当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#root&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">,</span> <span class="token string">&#39;触发事件的元素&#39;</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">,</span> <span class="token string">&#39;事件的类型&#39;</span><span class="token punctuation">)</span>
  <span class="token comment">// event.preventDefault()  阻止默认事件</span>
  <span class="token comment">// event.stopPropagation() 阻止冒泡</span>
<span class="token punctuation">}</span>

el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="事件委派" tabindex="-1"><a class="header-anchor" href="#事件委派" aria-hidden="true">#</a> 事件委派</h3><p>将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。</p><p>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</p><h3 id="事件传播机制" tabindex="-1"><a class="header-anchor" href="#事件传播机制" aria-hidden="true">#</a> 事件传播机制</h3><p>事件传播有三个阶段：</p><p>1.<strong>捕获阶段</strong>：在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件</p><p>2.<strong>目标阶段</strong>：事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p><p>3.<strong>冒泡阶段</strong>：事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</p><h3 id="鼠标事件" tabindex="-1"><a class="header-anchor" href="#鼠标事件" aria-hidden="true">#</a> 鼠标事件</h3><p>下面是一些常见的鼠标事件类型：</p><p><strong>mousedown</strong>（鼠标按下） <strong>mousemove</strong>（鼠标移动） <strong>mouseup</strong>（鼠标松开）</p><p><strong>mousewheel</strong>（鼠标滚轮滚动） <strong>focus</strong> (获取焦点) <strong>blur</strong> （失去焦点）</p><p><strong>mouseover</strong>(鼠标经过，会冒泡，经过子元素也会触发事件)</p><p><strong>mouseout</strong>（鼠标离开，会冒泡，离开子元素但仍在元素内 或 从绑定元素移动到子元素也会触发，因为子元素遮盖了父元素的可视区域）</p><p><strong>mouseenter</strong>（鼠标进入，不会冒泡，仅进入自身元素触发）</p><p><strong>mouseleave</strong>（鼠标离开，不会冒泡，仅离开自身元素触发）</p><p>以及事件对象种关于鼠标的相关位置信息：</p><p><strong>event.clientX/clientY</strong> 返回触发时鼠标相对于浏览器窗口可视区的X/Y坐标</p><p><strong>event.pageX/pageY</strong> 返回触发时鼠标相对于页面文档的X/Y坐标</p><p><strong>event.screenX/screenY</strong> 返回触发时鼠标相对于显示器屏幕的X/Y坐标</p><p><strong>event.offsetX/offsetY</strong> 返回触发时鼠标相对于触发元素内填充边的X/Y坐标</p><h3 id="键盘事件" tabindex="-1"><a class="header-anchor" href="#键盘事件" aria-hidden="true">#</a> 键盘事件</h3><p>下面是一些常见的键盘事件类型：</p><p>keydown（按键按下） onkeyup（按键松开）</p><p>并且使用 <strong>event.keyCode</strong> 来判断按下了哪一个按键。</p>`,63),l=[o];function p(c,i){return e(),s("div",null,l)}const u=n(a,[["render",p],["__file","dom.html.vue"]]);export{u as default};
